<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Math87-Tufts University - week02-03--root-finding</title>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>	
        <link rel="stylesheet" href="../css/default.css" />
	<link rel="stylesheet" href="../css/haddock.css" />
	
	<link href="https://fonts.googleapis.com/css?family=Lato:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Arimo:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Roboto:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" type="text/css" rel="stylesheet" media="screen" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous" />			
    </head>
    <body>
        <header>
          <div class="logo">
            <a href="../">
	      Math87 - Spring 2024 - Tufts Univ</a>
          </div>
          <nav>
            <a href="../about.html">About</a>
	    <a href="../course-pages/Math087--course-info.html">Info</a>	    
            <a href="../archive.html">Archive</a>
          </nav>
        </header>

        <main role="main">
            <h1>week02-03--root-finding</h1>
            <div id="ed96307a-0c3a-4174-b078-cc2d59898757" class="cell markdown">

</div>
<div id="ef80e7ac-612d-4bfe-b162-b58cfb1d5eb6" class="cell markdown">
<h1 id="george-mcninch-math-87---spring-2024"><a href="http://gmcninch.math.tufts.edu">George McNinch</a> Math 87 - Spring 2024</h1>
<hr />
<h1 id="-root-finding">§ Root Finding</h1>
</div>
<div id="da8c77b2-9610-44cb-a32d-9701119fc03a" class="cell markdown">
<h1 id="overview">Overview</h1>
<p>We are often interesting in finding solutions to (non-linear) equations
<span class="math inline">\(𝑓(𝑥)=0\)</span>.</p>
<p>Here we describe various methods for finding such solutions under
assumptions and requirements.</p>
<p>By a root of <span class="math inline">\(𝑓\)</span>, we just mean a real number <span class="math inline">\(𝑥_0\)</span> such that <span class="math inline">\(𝑓(𝑥_0)=0\)</span>.</p>
<p>Of course, for some very special functions <span class="math inline">\(𝑓\)</span>, we have formulas for
roots. For example, if <span class="math inline">\(𝑓\)</span> is a quadratic polynomial, say
<span class="math inline">\(𝑓(𝑥)=𝑎𝑥^2+𝑏𝑥+𝑐\)</span> for real numbers <span class="math inline">\(𝑎,𝑏,𝑐\)</span>, then there are in general two
roots, given by the <em>quadratic formula</em>
<span class="math display">\[𝑥_0=\dfrac{−𝑏±\sqrt{𝑏^2−4𝑎𝑐}}{2𝑎}.\]</span> (Of course, these roots are only
real numbers in case of <span class="math inline">\(𝑏^2−4 𝑎 𝑐 \ge 0\)</span>).</p>
<p>But such a formula is far too much to ask for, in general!</p>
<p>We describe here algorithmic methods for approximating roots of “nice
enough” functions which are less precise but more generally applicable.</p>
</div>
<div id="64115675-5d80-4561-b052-2d03a19300c6" class="cell markdown">
<h1 id="bisection---overview">Bisection - overview</h1>
<p>The bisection algorithm permits one to approximate a root of a
continuous function <span class="math inline">\(𝑓\)</span>, provided that one knows points <span class="math inline">\(𝑥_𝐿&lt;𝑥_𝑅\)</span> in the
domain of <span class="math inline">\(𝑓\)</span> for which the function values <span class="math inline">\(𝑓(𝑥_𝐿)\)</span> and <span class="math inline">\(𝑓(𝑥_𝑅)\)</span> are
non-zero and have opposite signs. The algorithm then returns an
approximate root in the interval <span class="math inline">\((𝑥_𝐿,𝑥_𝑅)\)</span>.</p>
<p>Of course, for a continuous <span class="math inline">\(𝑓\)</span> the <em>intermediate value theorem</em> implies
that there is at least one root <span class="math inline">\(𝑥_0\)</span> of <span class="math inline">\(𝑓\)</span> in the interval <span class="math inline">\((𝑥𝐿,𝑥𝑅)\)</span>.</p>
<p>To find a root, the algorithm iteratively divides the interval
<span class="math inline">\([𝑥_𝐿,𝑥_𝑅]\)</span> into two sub-intervals by introducing the midpoint
<span class="math inline">\(𝑥_𝐶=\dfrac{𝑥_𝐿+𝑥_𝑅}{2}\)</span>. It examines the signs of the values <span class="math inline">\(𝑓(𝑥_𝐿)\)</span>,
<span class="math inline">\(𝑓(𝑥_𝐶)\)</span> and <span class="math inline">\(𝑓(𝑥_𝑅)\)</span> and discards the interval on which the sign
doesn’t change. (Of course, if <span class="math inline">\(𝑓(𝑥_𝐶)\)</span> happens to be zero, that is the
root!)</p>
<p>So for example, if <span class="math inline">\(𝑓(𝑥_𝐿)\)</span> and <span class="math inline">\(𝑓(𝑥_𝐶)\)</span> differ in sign, the procedure
is repeated on this smaller interval <span class="math inline">\([𝑥_𝐿,𝑥_𝐶]\)</span>.</p>
<p>One way of looking at the “theory” underlying the use of this algorithm
is the following: writing <span class="math inline">\(x_N\)</span> for the approximate solution returned by
the algorithm after <span class="math inline">\(N\)</span> iterations, one knows that the limit
<span class="math display">\[\lim_{N \to \infty} x_N\]</span> exists and is a solution to <span class="math inline">\(f(x) = 0\)</span> – in
words: the estimates converge to a solution.</p>
<p>The <code>python</code> library <code>scipy</code> has an <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.bisect.html#scipy.optimize.bisect">implementation of the bisection
algorithm</a>,
which we can use.</p>
<p>This implementation is found in the <code>scipy.optimization</code> library, and
the function has the following specification:</p>
</div>
<div id="8f89cd01-57c6-4b78-a7e6-d5bd1e1ac397" class="cell markdown">
<p><code>{python} scipy.optimize.bisect(f,a,b,args=(),                        xtol=2e-12,                        rtol=8.881784197001252e-16,                        maxiter=100,                        full_output=False,                        disp=True)</code></p>
</div>
<div id="abf1f3f0-22ca-4390-88a9-371a621bfea1" class="cell markdown">
<p>Here <code>f</code> is the function in question, and <code>a</code> and <code>b</code> are the values
bracketing some root of <code>f</code>.</p>
<p>Morally, the argument <code>rtol</code> indicates the desired tolerance – thus the
function should return a value <code>x</code> for which <code>|f(x)| &lt; rtol</code>. In
practice, things are a bit more complicated (read the docs when
required…!)</p>
<p>Also:</p>
<blockquote>
<p>If convergence is not achieved in <code>maxiter</code> iterations, an error is
raised. Must be &gt;= 0.</p>
</blockquote>
</div>
<div id="7e304b31-df23-4f10-82f1-7c66a9159be1" class="cell markdown">
<h1 id="example">Example</h1>
<p>For example, we can use ‘bisect’ to approximate the roots of <span class="math display">\[f(x) =
x^2 - x -1\]</span>. Recall that those roots are <span class="math display">\[\dfrac{1 \pm \sqrt{5}}{2}.\]</span></p>
</div>
<div id="9cb9191d-09c7-4047-bc1a-29eca6b380d9" class="cell code">
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> bisect</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> x <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">## lets make a list of the solutions</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>approx_sol <span class="op">=</span> np.array([bisect(f,<span class="dv">1</span>,<span class="dv">2</span>),</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                       bisect(f,<span class="op">-</span><span class="dv">2</span>,<span class="dv">0</span>)])</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>sol_via_radicals <span class="op">=</span> np.array([(<span class="dv">1</span><span class="op">+</span>np.sqrt(<span class="dv">5</span>))<span class="op">/</span><span class="dv">2</span>,</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                             (<span class="dv">1</span><span class="op">-</span>np.sqrt(<span class="dv">5</span>))<span class="op">/</span><span class="dv">2</span> ])</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>report <span class="op">=</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>.join([<span class="ss">f&quot;bisection solutions: </span><span class="sc">{</span>approx_sol<span class="sc">}</span><span class="ss">&quot;</span>,</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                    <span class="ss">f&quot;via radicals:        </span><span class="sc">{</span>sol_via_radicals<span class="sc">}</span><span class="ss">&quot;</span>,</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                    <span class="ss">f&quot;difference:          </span><span class="sc">{</span>approx_sol<span class="op">-</span>sol_via_radicals<span class="sc">}</span><span class="ss">&quot;</span>])</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(report)</span></code></pre></div>
</div>
<div id="a6be5123-a000-485a-be7a-83541065cb19" class="cell markdown">
<p><strong>Question</strong>: what does this <code>bisect</code>function do if <code>f(a)</code> and <code>f(b)</code>
have the same sign?</p>
<h1 id="example">Example</h1>
<p>We can estimate zeros of the <span class="math inline">\(\sin\)</span> function - here we get an
approximation to <span class="math inline">\(\pi\)</span>, since we happen to know that <span class="math inline">\(\sin(1) &gt;0\)</span>,
<span class="math inline">\(\sin(4)&lt;0\)</span>, and <span class="math inline">\(\pi\)</span> is the unique root of <span class="math inline">\(\sin(x)=0\)</span> between <span class="math inline">\(1\)</span> and
<span class="math inline">\(4\)</span>:</p>
</div>
<div id="7b3bd11a-d433-443f-8d3f-0f09cc7c68b8" class="cell code">
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> g(x): <span class="cf">return</span> np.sin(x)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>bisect(g,<span class="dv">1</span>,<span class="dv">4</span>)</span></code></pre></div>
</div>
<div id="123116ac-2f1c-42c3-9b5f-5a7475235cf1" class="cell markdown">
<p><strong>Question</strong>: How does this solution compare with the value of pi stored
by <code>numpy</code>?</p>
<p>(Compare with <code>np.pi</code>)</p>
<h1 id="example">Example</h1>
<p>And we can estimate the transcendental number <span class="math inline">\(e = \exp(1)\)</span> e.g. by
finding roots of the function <span class="math inline">\(f(x) = 1 - \ln(x)\)</span>:</p>
<p>(<strong>Question</strong>: try comparing the answer with <code>np.exp(1)</code>).</p>
</div>
<div id="25601e9b-6df1-45f0-8b79-76b3f8df6aac" class="cell code">
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> h(x):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">-</span> np.log(x)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>bisect(h,<span class="dv">1</span>,<span class="dv">3</span>)</span></code></pre></div>
</div>
<div id="deb9dc55-a973-49a1-b03c-1d42c7e2e16b" class="cell markdown">
<p>Here are some slightly more sophisticated methods of approximating
roots:</p>
<h1 id="secant-method">Secant Method</h1>
<p><a href="https://en.wikipedia.org/wiki/Secant_method">You can read the wikipedia
description</a> of the secant
method here.</p>
<blockquote>
<p>The secant method is a root-finding algorithm that uses a succession
of roots of secant lines to better approximate a root of a function f.</p>
</blockquote>
<h1 id="newtons-method">Newton’s method</h1>
<p><a href="https://en.wikipedia.org/wiki/Newton%27s_method">And here is the wikipedia description of Newton’s
method</a>.</p>
<blockquote>
<p>it is a root-finding algorithm which produces successively better
approximations to the roots (or zeroes) of a real-valued function. The
most basic version starts with a single-variable function <span class="math inline">\(f\)</span> defined
for a real variable <span class="math inline">\(x\)</span>, the function’s derivative <span class="math inline">\(f'\)</span>, and an
initial guess <span class="math inline">\(x_0\)</span> for a root of <span class="math inline">\(f\)</span>.</p>
</blockquote>
<p>Let’s quickly summarize the simplest form of Newton’s method:</p>
<p>If the function is sufficiently “nice” and if the initial guess <span class="math inline">\(x_0\)</span> is
close enough to a root, then</p>
<p><span class="math display">\[x_1 = x_0 − \dfrac{f(x_0)}{f'(x_0)}\]</span></p>
<p>is a better approximation of the root than <span class="math inline">\(x_0\)</span>. Notice that <span class="math inline">\(x_1\)</span> is
the <span class="math inline">\(x\)</span>-coordinate of the point of intersection of the <span class="math inline">\(x\)</span>-axis with the
tangent line to <span class="math inline">\(f\)</span> at <span class="math inline">\((x_0,f(x_0)\)</span>.</p>
<p>The process is then iterated: for <span class="math inline">\(n \ge 2\)</span>, we set <span class="math display">\[x_n = x_{n-1} -
\dfrac{f(x_{n-1})}{f'(x_{n-1})}.\]</span></p>
<p>Under favorable circumstances, <span class="math inline">\(\lim_{n \to \infty} x_n\)</span> is a root of
<span class="math inline">\(f\)</span>.</p>
<p>The <code>scipy</code> library makes both the secant method and Newton’s method
available via
<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html">scipy.optimize.newton</a></p>
</div>
<div id="4f768171-e445-400d-a1d3-b5418567afb3" class="cell markdown">
<p><code>{python} scipy.optimize.newton(func, x0,                        fprime=None,                        args=(),                        tol=1.48e-08,                        maxiter=50,                        fprime2=None,                        x1=None,                        rtol=0.0,                        full_output=False,                        disp=True)</code></p>
</div>
<div id="9418caf7-5fcd-4172-85c6-99316e27d8f3" class="cell markdown">
<p>The mandatory arguments to this function are <code>func</code> and the initial
guess <code>x0</code>. If the derivative <code>fprime</code> is given, this function uses
Newton’s method to approximate a root.</p>
<p>If the value of <code>fprime2</code> is <code>None</code> - the default value – then this
function uses either Newton’s method or the secant method to approximate
a root of <span class="math inline">\(f\)</span>. (If a second derivative <code>fprime2</code> is given, then
<a href="https://en.wikipedia.org/wiki/Halley%27s_method">Halley’s method</a> is
used).</p>
<p>Assuming <code>fprime2 = None</code>, whether to use Newton’s method or the secant
method is determined by the value of <code>fprime</code>.</p>
<p>If the value of <code>fprime</code> is <code>None</code> (the default value), then this
function uses the secant method to approximate a root of <span class="math inline">\(f\)</span>. It then
requires a value other than <code>None</code> for the <code>x1</code> argument (since the
secant method requires <em>two</em> initial values).</p>
<p>If <code>fprime</code> is given, this function uses Newton’s method to approximate
a root.</p>
<p>Let’s repeat the preceding examples:</p>
<h2 id="example">Example</h2>
<ul>
<li><span class="math inline">\(f(x) = x^2 - x -1\)</span>.</li>
</ul>
</div>
<div id="ec9fc341-a286-4561-ba4e-ddbd33809536" class="cell code">
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> newton</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x):</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> x <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">## secant method</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>sec<span class="op">=</span>[newton(f,<span class="dv">1</span>,x1<span class="op">=</span><span class="dv">2</span>),newton(f,<span class="op">-</span><span class="dv">1</span>,x1<span class="op">=-</span><span class="dv">2</span>)]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co">## Newton's method</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fprime(x):</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span><span class="op">*</span>x <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>newt<span class="op">=</span>[newton(f,<span class="dv">1</span>,fprime),newton(f,<span class="op">-</span><span class="dv">1</span>,fprime)]</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>report <span class="op">=</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>.join([<span class="ss">f&quot;secant </span><span class="sc">{</span>sec<span class="sc">}</span><span class="ss">&quot;</span>,</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                    <span class="ss">f&quot;newton </span><span class="sc">{</span>newt<span class="sc">}</span><span class="ss">&quot;</span>,])</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(report)</span></code></pre></div>
</div>
<div id="48ba47cc-be0b-4680-a37e-05744418fbd7" class="cell markdown">
<h1 id="example">Example</h1>
<p><span class="math inline">\(\pi\)</span> via <span class="math inline">\(\sin\)</span></p>
</div>
<div id="6a6c681b-57e4-4bf9-991c-109936d834ff" class="cell code">
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">## use the secant method with x0 = 1 and x1 = 4</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>sec_pi <span class="op">=</span> newton(np.sin,<span class="fl">1.0</span>,x1<span class="op">=</span><span class="fl">4.0</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">## use newton's method with x0=1</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>newt_pi <span class="op">=</span> newton(np.sin,<span class="dv">2</span>,fprime<span class="op">=</span>np.cos)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>report <span class="op">=</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>.join([<span class="ss">f&quot;secant: </span><span class="sc">{</span>sec_pi<span class="sc">}</span><span class="ss">&quot;</span>,</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                    <span class="ss">f&quot;newton: </span><span class="sc">{</span>newt_pi<span class="sc">}</span><span class="ss">&quot;</span>])</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(report)</span></code></pre></div>
</div>
<div id="bda4f616-65c1-412f-8357-ef52c550ca89" class="cell markdown">
<h1 id="example">Example:</h1>
<p><span class="math inline">\(e\)</span> via <span class="math inline">\(h(x) = 1 - \ln(x)\)</span>.</p>
</div>
<div id="a314905f-93ad-4a79-9775-f76904622fa7" class="cell code">
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> h(x):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">-</span> np.log(x)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hprime(x):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">/</span>x</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>e_secant <span class="op">=</span> newton(h,<span class="dv">2</span>,x1<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>e_newt   <span class="op">=</span> newton(h,<span class="dv">3</span>,fprime<span class="op">=</span>hprime)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>report <span class="op">=</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>.join([<span class="ss">f&quot;secant: </span><span class="sc">{</span>e_secant<span class="sc">}</span><span class="ss">&quot;</span>,</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>                    <span class="ss">f&quot;newton: </span><span class="sc">{</span>e_newt<span class="sc">}</span><span class="ss">&quot;</span>])</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(report)</span></code></pre></div>
</div>
<div id="d5c85e8b-dc61-4af5-a57b-6ad46fa14d68" class="cell markdown">
<p><strong>Question</strong>: what was the role of <span class="math inline">\(x_0\)</span> and <span class="math inline">\(x_1\)</span> in the above secant
method examples? and what was the role of <span class="math inline">\(x_0\)</span> in the above
newton-method examples?</p>
<p>See what happens when you vary <span class="math inline">\(x_0\)</span> in the computation of <code>newt_pi</code>
above.</p>
<p>See what happens when you give <code>newton</code> an incorrect first derivative.</p>
</div>
<div id="555b25fd-a539-4f6f-ae1a-7853683293ac" class="cell markdown">
<h1 id="modeling-exaample">Modeling exaample</h1>
<p>A large population of <span class="math inline">\(N\)</span> people need to be tested for a disease. In
order to reduce the costs of testing, a grouping strategy is proposed:
Take blood samples from each person in a group of <span class="math inline">\(x\)</span> people. Divide
each sample in half and mix one-half of each person’s sample into one
mixture. Test the mixture. If it is negative, then we know that all <span class="math inline">\(x\)</span>
people in the group are negative. If it is positive, then at least one
person in that group is positive, so test the other half of each
person’s sample. What value of <span class="math inline">\(x\)</span> minimizes the total number of tests
that needs to be done?</p>
<p>Variables:</p>
<ul>
<li><span class="math inline">\(N\)</span> = total population</li>
<li><span class="math inline">\(x\)</span> = group size</li>
<li><span class="math inline">\(q\)</span> = probability of one individual testing negative</li>
<li><span class="math inline">\(T\)</span> = total number of tests</li>
<li><span class="math inline">\(T_g\)</span> = total number of group tests</li>
<li><span class="math inline">\(T_i\)</span> = expected number of individual tests</li>
<li><span class="math inline">\(T = T_g + T_i\)</span></li>
</ul>
<p>The number of group tests is just the population/group size,
<span class="math inline">\(T_g = N/x\)</span>.</p>
<p>For <span class="math inline">\(T_i\)</span> we have <span class="math inline">\(N/x\)</span> groups of <span class="math inline">\(x\)</span> people and the probability of all
people in the group being negative is <span class="math inline">\(q^x\)</span>. Thus, the probability of
one person in the group testing positive is <span class="math inline">\(1 − q^x\)</span>. If this happens,
we have to do x tests! So…</p>
<p><span class="math display">\[T_i = \dfrac{N}{x}\left[(1-q^x)x \right] = N\left(1-q^x\right).\]</span></p>
<p>and thus</p>
<p><span class="math display">\[T = T_i + T_g = \dfrac{N}{x} + N(1-q^x) = N(\dfrac{1}{x} + 1 -
q^x).\]</span></p>
<p>To find the value of <span class="math inline">\(x\)</span> that yields the minimum number of required
tests, we need to solve the equation <span class="math inline">\(\dfrac{dT}{dx} = 0\)</span>.</p>
<p>Well, <span class="math display">\[\dfrac{dT}{dx} = N\left(\dfrac{-1}{x^2} - q^x \ln q\right).\]</span></p>
<p>Since <span class="math inline">\(q\)</span> represents a <em>probability</em>, we have <span class="math inline">\(0&lt;q&lt;1\)</span>. In particular,
<span class="math inline">\(\ln(q) &lt; 0\)</span>. Thus in order that <span class="math inline">\(\dfrac{dT}{dx} = 0\)</span>. we must have
<span class="math display">\[g(x) = \dfrac{-1}{x^2} - (\ln q)q^x = 0.\]</span></p>
<p>It is not easy to directly solve the equation <span class="math inline">\(g(x) = 0\)</span>. So we will
apply Newton’s method. For this, we need to know <span class="math inline">\(g'(x)\)</span> as well; it is</p>
<p><span class="math display">\[g'(x) = \dfrac{2}{x^3} - (\ln q)^2 q^x.\]</span></p>
</div>
<div id="52acb095-73c2-4351-b2b5-16b112d51a84" class="cell code">
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> g(q,x):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="op">-</span><span class="dv">1</span><span class="op">/</span>x<span class="op">**</span><span class="dv">2</span>) <span class="op">-</span> np.log(q)<span class="op">*</span> q<span class="op">**</span>x</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gprime(q,x):</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span><span class="op">/</span>x<span class="op">**</span><span class="dv">3</span> <span class="op">-</span> (np.log(q))<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> q<span class="op">**</span>x</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>q_values <span class="op">=</span> [<span class="fl">0.7</span>, <span class="fl">0.8</span>, <span class="fl">0.9</span>, <span class="fl">0.95</span>, <span class="fl">0.99</span>, <span class="fl">0.999</span>, <span class="fl">0.9999</span>]</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">## note that partial(g,q) returns the function given by h(x) = g(q,x)</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">## in other words, we &quot;partially evaluate&quot; the function g(q,x) to get a function </span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">## only of x.</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> newt(q): </span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> newton(partial(g,q),<span class="dv">2</span>,fprime<span class="op">=</span>partial(gprime,q))</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="co"># the following code returns a list of pairs (q,newt(q))</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="co"># where q runs through the list q_values.</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Here, newt(q) is the solution to g(q,x) = 0 obtained from Newton's method</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="co"># (with x0 = 2).</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(<span class="bu">map</span>(<span class="kw">lambda</span> x: (x,newt(x)),q_values))</span></code></pre></div>
</div>
        </main>

        <footer>
	  <nav>
	    <a href="http://www.tufts.edu">
	      <i class="fas fa-chalkboard"></i>
	      Tufts
	    </a>	    
	    <a href="http://math.tufts.edu">
	      <i class="fas fa-chalkboard-teacher"></i>
	      Tufts Math
	    </a>
	    <a href="https://gmcninch-tufts.github.io/math">
	      <i class="fas fa-coffee"></i>
	      G McNinch
	    </a>
	    <a href="https://github.com/gmcninch-tufts">
	      <i class="fab fa-github"></i>
	      GitHub
	    </a>	    
	  </nav>
        </footer>
    </body>
</html>
