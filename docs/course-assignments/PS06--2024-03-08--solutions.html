<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Math87-Tufts University - PS 06 -- Markov Processes</title>
	<script>
	  window.MathJax = {
	    options: {
	      ignoreHtmlClass: 'tex2jax_ignore',
	      processHtmlClass: 'tex2jax_process'
	    },
	    tex: {
	      autoload: {
		color: [],
		colorv2: ['color']
	      },
	      packages: {'[+]': ['noerrors']}
	    },
	    loader: {
	      load: ['input/asciimath', '[tex]/noerrors']
	    }
	  };
	</script>
	<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>
        <link rel="stylesheet" href="../css/default.css" />
	<link rel="stylesheet" href="../css/haddock.css" />
	
	<link href="https://fonts.googleapis.com/css?family=Lato:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Arimo:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Roboto:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" type="text/css" rel="stylesheet" media="screen" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous" />			
    </head>
    <body>
        <header>
          <div class="logo">
            <a href="../">
	      Math87 - Spring 2024 - Tufts Univ</a>
          </div>
          <nav>
            <a href="../about.html">About</a>
	    <a href="../course-pages/Math087--course-info.html">Info</a>	    
            <a href="../archive.html">Archive</a>
          </nav>
        </header>

        <main role="main">
            <h1>PS 06 -- Markov Processes</h1>
            <ol type="1">
<li><p>Suppose you’re standing on a street with buildings labelled by the
integers (specifically, you’re in front of the building labelled
<span class="math inline">\(0\)</span>, and suppose that the indices are increasing to the
right). Suppose that every minute you flip a coin. If the coin is
heads you walk right and if the coin is tails you walk left.</p>
<ol type="a">
<li><p>Explain why your position (i.e. the building you’re in front of)
as a function of time can be modeled as a Markov process.</p>
<div class="solution">
<p>Your position at time t is (randomly chosen to be) one step to
the left or to the right of your previous position, and hence is
only dependent on your position at time t − 1. It doesn’t matter
(for instance) what sequence of steps took you to get to your
position at time t − 1, and hence this is a Markov chain.</p>
<p>Somewhat more precisely, the nodes of the <em>transition diagram</em>
are in one-to-one correspondence with the integers <span class="math inline">\(\{0, \pm 1, \pm 2, \cdots\}\)</span>, and each node <code>[n]</code> has two outgoing
edges. There is an edge <code>[n] --&gt; [n+1]</code> labeled with probability
1/2, and an edge <code>[n-1] &lt;-- [n]</code> also labeled with probability
1/2. Thus, the probabilities on the outgoing edges always sum to 1.</p>
<p>And the state of the system evolves each minute by applying the
rules of this <em>state machine</em>; this is the definition of a
<em>Markov process</em> (or <em>Markov chain</em>).</p>
</div></li>
<li><p>Can the distance from where you started as a function of time be
modeled by a Markov process?</p>
<div class="solution">
<p>Yes. In this case, consider the <em>transition diagram</em> whose nodes
are <em>non-negative</em> integers. For any node <code>[n]</code> with <code>n&gt;0</code>,
there are <em>two</em> outgoing edges: <code>[n] --&gt; [n+1]</code> and <code>[n-1] &lt;-- [n]</code>, both of which are labeled with probability 1/2.</p>
<p>If you are standing in front of building <code>m</code> - so that the
distance from building <code>0</code> is <code>|m|</code> - , the effect of a <code>heads</code>
toss and of a <code>tails</code> toss depend on the <em>sign</em> of <code>m</code>. Namely,
if <code>m&gt;0</code> and you toss <code>heads</code>, you move one building to the
right and hence increase your distance to the origin by one
unit, and if you toss <code>tails</code>, you move one building to the left
and hence decrease your distance to the origin by one unit.</p>
<p>On the other hand, if <code>m&lt;0</code> and you toss <code>heads</code>, your
one-building to the right move <em>increases</em> your distance to the
origin by one unit, and if you toss <code>tails</code>, your distance to
the origin <em>decreases</em> by one unit.</p>
<p>Finally, if your distance is <code>0</code>, there is only one outgoing
edge <code>[0] --&gt; [1]</code> and it has a probability of 1, since a toss
of either <code>heads</code> or <code>tails</code> results in a move placing you
exactly 1 unit from the origin.</p>
<p>In summary, <code>distance to the origin</code> is governed by the
transition diagram we just described, hence is a Markov process.</p>
</div></li>
<li><p>Now suppose that every minute you flip two coins. If both are
heads, you move right, if both are tails you move left and
otherwise you stay put. Is your distance from where you started
modeled by a Markov process in this scenario? How do you expect
this to compare to the process described in part b?</p>
<div class="solution">
<p>This is again a Markov process, with a different transition
diagram which we now describe.</p>
<p>Again the nodes of the diagram are non-negative integers <code>[n]</code>.</p>
<p>The outgoing edges from <code>[0]</code> are a loop <code>[0] --&gt; [0]</code> together
with an edge <code>[0] --&gt; [1]</code>. In this case each edge occurs with
probability 1/2. (A result of <code>heads,head</code> or <code>tails,tails</code>
causes a move <code>[0] --&gt; [1]</code>, while a mixed toss results in the
move <code>[0] --&gt; [0]</code>.</p>
For <code>|n| &gt; 0</code>, there are 3 outgoing edges from <code>[n]</code>:
<ul>
<li><code>[n] --&gt; [n]</code> is labeled with probability 1/2 and results from
<code>heads,tails</code> or <code>tails,heads</code></li>
<li><code>[n] --&gt; [n+1]</code> is labeled with probability 1/4; if <code>n&gt;0</code> this
move results from <code>heads,head</code> while if <code>n&lt;0</code> this move
results from <code>tails,tails</code>.</li>
<li><code>[n] --&gt; [n-1]</code> is also labeled with probability 1/4; if <code>n&gt;0</code> this
move results from <code>tails,tails</code> while if <code>n&lt;0</code> this move results
from <code>heads,heads</code>.</li>
</ul>
</div></li>
<li><p>For both experiments, compute the probability that you are
standing on an odd number for minute <span class="math inline">\(0,1,2,3,4\)</span>.</p>
<div class="solution">
<p>I’ll do this calculation with the following code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pprint <span class="im">import</span> pprint</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># we represent the probabilities for a certain state</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># of our system using a dictionary</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># The initial state is { 0:1 } - this means with probability 1 you are at distance 0</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># The state { 0: p0, 1: p1, 2: p2, ... } indicates that with probability pi you are ate distance i.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prob(state,pos):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># return the probability recorded in the state dictionary for the indicated position</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pos <span class="kw">in</span> state.keys():</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> state[pos]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> step(f,state):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># update the state using the transition function f</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># f should be a function of two arguments: f(old_pos,new_pos)</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># should return the probability of transitioning from old_pos to new_pos</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We use f to update the probabilities, and we return the new state</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> <span class="bu">len</span>(state.keys())</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> { r: f(r<span class="op">-</span><span class="dv">1</span>,r)<span class="op">*</span>prob(state,r<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> f(r,r)<span class="op">*</span>prob(state,r) <span class="op">+</span> f(r<span class="op">+</span><span class="dv">1</span>,r)<span class="op">*</span>prob(state,r<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>             <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(results<span class="op">+</span><span class="dv">1</span>) }</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> iterate(num,f,init):</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># given a starting state `init`, return the state after `num` iterations,</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># using the function `f` as input to `step`.</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num<span class="op">&lt;=</span><span class="dv">0</span>:</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> init</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> iterate(num<span class="op">-</span><span class="dv">1</span>,f,step(f,init))</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prob_odd(state):</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for a given state, return the probability that the distance from</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># building 0 is *odd*</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>([ state[r] <span class="cf">for</span> r <span class="kw">in</span> state.keys() <span class="cf">if</span> r <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span> ])</span></code></pre></div>
<p>In the case described in (b), using only one coin, we define a
function computing the probabilities for state transitions in
the single-coin case. We find the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># we'll use this function as the update function f when</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># calling the `step` function defined above.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> one_coin(old_pos,new_pos):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># return the probability of </span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># transition from old_pos to new_pos</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    match (old_pos,new_pos):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">0</span>,<span class="dv">1</span>:  <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">0</span>,_:  <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> m,n: </span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(m<span class="op">-</span>n) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="fl">.5</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> [ (m,iterate(m,one_coin,{<span class="dv">0</span>:<span class="dv">1</span>})) <span class="cf">for</span> m <span class="kw">in</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] ]</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> [ (m,prob_odd(state)) <span class="cf">for</span> (m,state) <span class="kw">in</span> S ]</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>pprint(S)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(T)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">0</span>, {<span class="dv">0</span>: <span class="dv">1</span>}),</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a> (<span class="dv">1</span>, {<span class="dv">0</span>: <span class="fl">0.0</span>, <span class="dv">1</span>: <span class="fl">1.0</span>}),</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a> (<span class="dv">2</span>, {<span class="dv">0</span>: <span class="fl">0.5</span>, <span class="dv">1</span>: <span class="fl">0.0</span>, <span class="dv">2</span>: <span class="fl">0.5</span>}),</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a> (<span class="dv">3</span>, {<span class="dv">0</span>: <span class="fl">0.0</span>, <span class="dv">1</span>: <span class="fl">0.75</span>, <span class="dv">2</span>: <span class="fl">0.0</span>, <span class="dv">3</span>: <span class="fl">0.25</span>}),</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a> (<span class="dv">4</span>, {<span class="dv">0</span>: <span class="fl">0.375</span>, <span class="dv">1</span>: <span class="fl">0.0</span>, <span class="dv">2</span>: <span class="fl">0.5</span>, <span class="dv">3</span>: <span class="fl">0.0</span>, <span class="dv">4</span>: <span class="fl">0.125</span>})]</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="fl">1.0</span>), (<span class="dv">2</span>, <span class="fl">0.0</span>), (<span class="dv">3</span>, <span class="fl">1.0</span>), (<span class="dv">4</span>, <span class="fl">0.0</span>)]	  </span></code></pre></div>
<p>Here we see that after 0,2,4 steps we are <em>never</em> in front
of an odd-numbered building, and after 1,3 steps we are <em>always</em>
in front of an odd-numbered building.</p>
<p>In the case described in (c), we find instead the following results:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># we'll use this function as the update function f when</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># calling the `step` function defined above.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">#	  </span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> two_coin(old_pos,new_pos):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># return the probability of </span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># transition from old_pos to new_pos	  </span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    match (old_pos,new_pos):</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">0</span>,<span class="dv">1</span>: <span class="cf">return</span> <span class="fl">.5</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">0</span>,<span class="dv">0</span>: <span class="cf">return</span> <span class="fl">.5</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> m,n:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> m<span class="op">==</span>n:</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="fl">.5</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">abs</span>(m<span class="op">-</span>n) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="fl">.25</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> [ (m,iterate(m,two_coin,{<span class="dv">0</span>:<span class="dv">1</span>})) <span class="cf">for</span> m <span class="kw">in</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] ]</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> [ (m,prob_odd(state)) <span class="cf">for</span> (m,state) <span class="kw">in</span> S ]</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>pprint(S)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(T)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">0</span>, {<span class="dv">0</span>: <span class="dv">1</span>}),</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a> (<span class="dv">1</span>, {<span class="dv">0</span>: <span class="fl">0.5</span>, <span class="dv">1</span>: <span class="fl">0.5</span>}),</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a> (<span class="dv">2</span>, {<span class="dv">0</span>: <span class="fl">0.375</span>, <span class="dv">1</span>: <span class="fl">0.5</span>, <span class="dv">2</span>: <span class="fl">0.125</span>}),</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a> (<span class="dv">3</span>, {<span class="dv">0</span>: <span class="fl">0.3125</span>, <span class="dv">1</span>: <span class="fl">0.46875</span>, <span class="dv">2</span>: <span class="fl">0.1875</span>, <span class="dv">3</span>: <span class="fl">0.03125</span>}),</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a> (<span class="dv">4</span>, {<span class="dv">0</span>: <span class="fl">0.2734375</span>, <span class="dv">1</span>: <span class="fl">0.4375</span>, <span class="dv">2</span>: <span class="fl">0.21875</span>, <span class="dv">3</span>: <span class="fl">0.0625</span>, <span class="dv">4</span>: <span class="fl">0.0078125</span>})]</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="fl">0.5</span>), (<span class="dv">2</span>, <span class="fl">0.5</span>), (<span class="dv">3</span>, <span class="fl">0.5</span>), (<span class="dv">4</span>, <span class="fl">0.5</span>)]	  </span></code></pre></div>
<p>So after 0 steps, we are (of course) never in front of an odd numbered building,
but after 1,2,3 or 4 steps we are in front of an odd numbered building
with probability 1/2.</p>
</div></li>
<li><p>(Optional food for thought) Suppose your friend is playing the
same game, but started at position −100. Do you think it is more
likely that you two will eventually meet or that you two will
never meet? Does this answer change when your friend starts at
−1? How about −10000000?</p>
<div class="solution">
<p>It is a fact that two random walkers will
eventually meet regardless of where they start.</p>
</div></li>
</ol></li>
<li><p><strong>Rain or shine</strong> On Planet X, the weather is strangely predictable:
The weather is always either sunny, rainy, foggy or snowy. If it
rains today, its sunny tomorrow. If it is sunny today, its rainy
tomorrow. If its foggy today, its not sunny tomorrow. Finally, the
weather is never the same two days in a row. Apart from these
rules, the weather is completely random, in that if e.g. its foggy
today it is equally likely to be either rainy or snowy
tomorrow. You live on Planet X and are trying to figure out what to
wear this week, so you’d like to develop a model for the weather.</p>
<ol type="a">
<li><p>Explain why the weather can be modeled as a Markov process. Write
out the transition matrix, and draw the corresponding finite
state machine.</p>
<div class="solution">
<p>The system is governed by a transition diagram for which the
probabilities on the outgoing edges from each node sum
to 1. Thus, the system is a <em>Markov process</em>.</p>
<p>We describe the <em>transition diagram</em>. It has 4 nodes: <code>sunny</code>,
<code>rainy</code>, <code>foggy</code> and <code>snowy</code>. We are going to draw the diagram
using <code>graphviz</code> so we describe the probabilities as a python
dictionary:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>weather <span class="op">=</span> [ <span class="st">'sunny'</span>, <span class="st">'rainy'</span>, <span class="st">'foggy'</span>, <span class="st">'snowy'</span> ]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>transitions <span class="op">=</span> {</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'rainy'</span>, <span class="st">'sunny'</span>): <span class="dv">1</span>,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>   (<span class="st">'sunny'</span>, <span class="st">'rainy'</span>): <span class="dv">1</span>,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>   <span class="op">**</span>{ (<span class="st">'foggy'</span>,w): <span class="dv">1</span><span class="op">/</span><span class="dv">2</span> <span class="cf">for</span> w <span class="kw">in</span> weather <span class="cf">if</span> w <span class="op">!=</span> <span class="st">'sunny'</span> <span class="kw">and</span> w <span class="op">!=</span> <span class="st">'foggy'</span> },</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>   <span class="op">**</span>{ (<span class="st">'snowy'</span>,w): <span class="dv">1</span><span class="op">/</span><span class="dv">3</span> <span class="cf">for</span> w <span class="kw">in</span> weather <span class="cf">if</span> w <span class="op">!=</span> <span class="st">'snowy'</span> }</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>transitions </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>{(<span class="st">'rainy'</span>, <span class="st">'sunny'</span>): <span class="dv">1</span>,</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a> (<span class="st">'sunny'</span>, <span class="st">'rainy'</span>): <span class="dv">1</span>,</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a> (<span class="st">'foggy'</span>, <span class="st">'rainy'</span>): <span class="fl">0.5</span>,</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a> (<span class="st">'foggy'</span>, <span class="st">'snowy'</span>): <span class="fl">0.5</span>,</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a> (<span class="st">'snowy'</span>, <span class="st">'sunny'</span>): <span class="fl">0.3333333333333333</span>,</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a> (<span class="st">'snowy'</span>, <span class="st">'rainy'</span>): <span class="fl">0.3333333333333333</span>,</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a> (<span class="st">'snowy'</span>, <span class="st">'foggy'</span>): <span class="fl">0.3333333333333333</span>}</span></code></pre></div>
<p>Now we create the labeled digram:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> graphviz <span class="im">import</span> Digraph</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>dot <span class="op">=</span> Digraph()</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>dot.attr(rankdir<span class="op">=</span><span class="st">'LR'</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> dot.subgraph() <span class="im">as</span> c:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    c.attr(rank<span class="op">=</span><span class="st">'same'</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    c.node(<span class="st">'rainy'</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    c.node(<span class="st">'sunny'</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> dot.subgraph() <span class="im">as</span> c:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    c.attr(rank<span class="op">=</span><span class="st">'same'</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    c.node(<span class="st">'foggy'</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    c.node(<span class="st">'snowy'</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> product</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (v1,v2) <span class="kw">in</span> product(weather,weather):</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (v1,v2) <span class="kw">in</span> transitions.keys():</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        dot.edge(v1,v2,<span class="ss">f&quot;</span><span class="sc">{</span>transitions[(v1,v2)]<span class="sc">:.02f}</span><span class="ss">&quot;</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>dot.render(<span class="st">'weather.png'</span>)</span></code></pre></div>
<p><img src="../course-assets/images/weather.png" /></p>
<p>And we create the transition matrix:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> npl</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transition_prob(v,w):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># get the probability for the transition v--&gt;w</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (v,w) <span class="kw">in</span> transitions.keys():</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> transitions[(v,w)]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> np.array([[ transition_prob(v,w) <span class="cf">for</span> v <span class="kw">in</span> weather] <span class="cf">for</span> w <span class="kw">in</span> weather ])</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>p</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>array([[<span class="fl">0.</span>        , <span class="fl">1.</span>        , <span class="fl">0.</span>        , <span class="fl">0.33333333</span>],</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>       [<span class="fl">1.</span>        , <span class="fl">0.</span>        , <span class="fl">0.5</span>       , <span class="fl">0.33333333</span>],</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>       [<span class="fl">0.</span>        , <span class="fl">0.</span>        , <span class="fl">0.</span>        , <span class="fl">0.33333333</span>],</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>       [<span class="fl">0.</span>        , <span class="fl">0.</span>        , <span class="fl">0.5</span>       , <span class="fl">0.</span>        ]])</span></code></pre></div>
</div></li>
<li><p>Check whether the conditions for the Perron-Frobenius theorem is
satisfied for this problem (aperiodic and strongly
connected). Explain your reasoning.</p>
<div class="solution">
<p>The hypothesis of the Frobenius-Perron theorem do not hold.
The transition diagram is not <em>strongly connected</em>. For example,
there is no path from the node <code>sunny</code> to the node <code>foggy</code>.</p>
</div></li>
<li><p>Do you expect power iteration to be effective for computing the
greatest eigenvector of your transition matrix?</p>
<div class="solution">
<p>Because the conclusion of the Frobenius-Perron theorem is not known to hold,
it is possible that <code>p</code> has more than one eigenvalue with absolute value 1.
In that case, power iteration will not help to compute the greatest eigenvector.</p>
</div></li>
<li><p>Find the eigenvalue decomposition for the transition matrix, and
the associated eigenvectors. Explain why these values confirm
your answer to part 2.</p>
<div class="solution">
<p>(the problem should have read: “Explain why these values confirm your answer to (c)”).</p>
<p>Let’s look at the eigenvalues of <code>p</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>vals,vecs <span class="op">=</span> npl.eig(p)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>vals</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>array([ <span class="fl">1.</span>        ,  <span class="fl">0.40824829</span>, <span class="op">-</span><span class="fl">1.</span>        , <span class="op">-</span><span class="fl">0.40824829</span>])</span></code></pre></div>
<p>We note that <code>p</code> has an eigenvalue 1, but also an eigenvalue -1.</p>
<p>If <code>v</code> is an eigenvector with eigenvalue -1, then</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>npl.matrix_power(p,n) <span class="op">@</span> v <span class="op">=</span> ± v</span></code></pre></div>
<p>depending on the parity of <code>n</code>.</p>
<p>So the long-term behavior of <em>powers of <code>p</code></em> fails to stabilize,
so we do not expect power iteration to be an effective way of
computing the greatest eigenvector.</p>
</div></li>
<li><p>Suppose that the “weather rules” change so that if its sunny
today, it is equally likely to be snowy or rainy tomorrow. Write
out the new transition matrix, associated finite state machine,
and determine whether the conditions for the Perron-Frobenius
are satisfied. Compute the eigenvalue decomposition and compare
to the previous set of eigenvalues.</p>
<div class="solution">
<p>We update the transition probabilities to reflect the new weather rules:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>new_transitions <span class="op">=</span> {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'rainy'</span>, <span class="st">'sunny'</span>): <span class="dv">1</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'sunny'</span>, <span class="st">'rainy'</span>): <span class="dv">1</span><span class="op">/</span><span class="dv">2</span>,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'sunny'</span>, <span class="st">'snowy'</span>): <span class="dv">1</span><span class="op">/</span><span class="dv">2</span>,</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">**</span>{ (<span class="st">'foggy'</span>,w): <span class="dv">1</span><span class="op">/</span><span class="dv">2</span> <span class="cf">for</span> w <span class="kw">in</span> weather <span class="cf">if</span> w <span class="op">!=</span> <span class="st">'sunny'</span> <span class="kw">and</span> w <span class="op">!=</span> <span class="st">'foggy'</span> },</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">**</span>{ (<span class="st">'snowy'</span>,w): <span class="dv">1</span><span class="op">/</span><span class="dv">3</span> <span class="cf">for</span> w <span class="kw">in</span> weather <span class="cf">if</span> w <span class="op">!=</span> <span class="st">'snowy'</span> }</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>We get a new diagram as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>new_dot <span class="op">=</span> Digraph(<span class="bu">format</span><span class="op">=</span><span class="st">'png'</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>dot.attr(rankdir<span class="op">=</span><span class="st">'LR'</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> dot.subgraph() <span class="im">as</span> c:</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    c.attr(rank<span class="op">=</span><span class="st">'same'</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    c.node(<span class="st">'rainy'</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    c.node(<span class="st">'sunny'</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> dot.subgraph() <span class="im">as</span> c:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    c.attr(rank<span class="op">=</span><span class="st">'same'</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    c.node(<span class="st">'foggy'</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    c.node(<span class="st">'snowy'</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (v1,v2) <span class="kw">in</span> product(weather,weather):</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (v1,v2) <span class="kw">in</span> new_transitions.keys():</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        dot.edge(v1,v2,<span class="ss">f&quot;</span><span class="sc">{</span>new_transitions[(v1,v2)]<span class="sc">:.02f}</span><span class="ss">&quot;</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>dot.render(<span class="st">'new_weather'</span>)		  </span></code></pre></div>
<p><img src="../course-assets/images/new_weather.png" /></p>
<p>And we get a new transition matrix <code>q</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> np.array([[ transition_prob(v,w,new_transitions) <span class="cf">for</span> v <span class="kw">in</span> weather] <span class="cf">for</span> w <span class="kw">in</span> weather ])</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>q</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>array([[<span class="fl">0.</span>        , <span class="fl">1.</span>        , <span class="fl">0.</span>        , <span class="fl">0.33333333</span>],</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>       [<span class="fl">0.5</span>       , <span class="fl">0.</span>        , <span class="fl">0.5</span>       , <span class="fl">0.33333333</span>],</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>       [<span class="fl">0.</span>        , <span class="fl">0.</span>        , <span class="fl">0.</span>        , <span class="fl">0.33333333</span>],</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>       [<span class="fl">0.5</span>       , <span class="fl">0.</span>        , <span class="fl">0.5</span>       , <span class="fl">0.</span>        ]])</span></code></pre></div>
<p>We observe that in this case, the transition diagram is <em>strong
connected</em>. Moreover, it is also acyclic e.g. because there are
cycles of length two (<code>snowy --&gt; foggy --&gt; snowy</code> for example)
as well as cycles of length three (<code>sunny --&gt; snowy --&gt; rainy --&gt; sunny</code>).
Since <code>gcd(2,3) = 1</code> there only natural number dividing all cycle lengths is 1.</p>
<p>Thus the Frobenius Perron Theorem holds. It promises that <code>q</code> has eigenvalue
1 with multiplicity 1. If <code>v</code> is an eigenvector with eigenvalue 1, normalized
so that <code>v</code> is a probability vector, then we know that</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>npl.matrix_power(p,n)</span></code></pre></div>
<p>converges as <span class="math inline">\(n \to \infty\)</span> to the matrix <code>B</code> with 4 columns equal to the vector <code>v</code>.</p>
<p>We can observe this phenomenon by compute “big” powers of <code>q</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>npl.matrix_power(q,<span class="dv">100</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>array([[<span class="fl">0.38461538</span>, <span class="fl">0.38461538</span>, <span class="fl">0.38461538</span>, <span class="fl">0.38461538</span>],</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>       [<span class="fl">0.30769231</span>, <span class="fl">0.30769231</span>, <span class="fl">0.30769231</span>, <span class="fl">0.30769231</span>],</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>       [<span class="fl">0.07692308</span>, <span class="fl">0.07692308</span>, <span class="fl">0.07692308</span>, <span class="fl">0.07692308</span>],</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>       [<span class="fl">0.23076923</span>, <span class="fl">0.23076923</span>, <span class="fl">0.23076923</span>, <span class="fl">0.23076923</span>]])	  </span></code></pre></div>
<p>We check the eigenvalues:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>vals,vecs <span class="op">=</span> npl.eig(q)  </span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>vals</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>array([ <span class="fl">1.</span>        , <span class="op">-</span><span class="fl">0.78867513</span>, <span class="op">-</span><span class="fl">0.21132487</span>,  <span class="fl">0.</span>        ])</span></code></pre></div>
<p>In this case, as promised by Frobenius-Perron, there is exactly
one eigenvalue with absolute value 1. All other eigenvalues <span class="math inline">\(\lambda\)</span>
have <span class="math inline">\(|\lambda| &lt; 1\)</span>.</p>
<p>Note that after normalizing, the eigenvector <code>vecs[:,0]</code> is close to the columns of the
matrix <span class="math inline">\(q^{100}\)</span> we computed above:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get the eigenvector computed by numpy for eigenvalue 1</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co"># remember that it is the first *column* of the matrix ev,</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co"># not the first row...!!</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>ev <span class="op">=</span> vecs[:,<span class="dv">0</span>]</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co"># normalize to make a probability vector</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> np.array([<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]) <span class="op">@</span> ev  <span class="co"># c is the sum of the entries of ev</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>p_ev <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>c)<span class="op">*</span>ev               <span class="co"># the entries of p_ev sum to 1</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>p_ev</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="op">=&gt;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>array([<span class="fl">0.38461538</span>, <span class="fl">0.30769231</span>, <span class="fl">0.07692308</span>, <span class="fl">0.23076923</span>])</span></code></pre></div>
</div></li>
</ol></li>
</ol>
        </main>

        <footer>
	  <nav>
	    <a href="http://www.tufts.edu">
	      <i class="fas fa-chalkboard"></i>
	      Tufts
	    </a>	    
	    <a href="http://math.tufts.edu">
	      <i class="fas fa-chalkboard-teacher"></i>
	      Tufts Math
	    </a>
	    <a href="https://gmcninch-tufts.github.io/math">
	      <i class="fas fa-coffee"></i>
	      G McNinch
	    </a>
	    <a href="https://github.com/gmcninch-tufts">
	      <i class="fab fa-github"></i>
	      GitHub
	    </a>	    
	  </nav>
        </footer>
    </body>
</html>
