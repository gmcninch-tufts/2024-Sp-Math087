<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Math87-Tufts University - Optimization and Linear Programming</title>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
	</script>	
        <link rel="stylesheet" href="../css/default.css" />
	<link rel="stylesheet" href="../css/haddock.css" />
	
	<link href="https://fonts.googleapis.com/css?family=Lato:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Arimo:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Roboto:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" type="text/css" rel="stylesheet" media="screen" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous" />			
    </head>
    <body>
        <header>
          <div class="logo">
            <a href="../">
	      Math87 - Spring 2024 - Tufts Univ</a>
          </div>
          <nav>
            <a href="../about.html">About</a>
	    <a href="../course-pages/Math087--course-info.html">Info</a>	    
            <a href="../archive.html">Archive</a>
          </nav>
        </header>

        <main role="main">
            <h1>Optimization and Linear Programming</h1>
            <h1 id="multivariable-optimization-with-constraints">Multivariable optimization with constraints</h1>
<h2 id="formulation">Formulation</h2>
<p>So far we have been looking at various optimization problems, but only
of very specific types. Optimization is clearly important and so we’d
like to describe some general strategy to help us tackle more problems.</p>
<p>So let’s describe what is more-or-less the most general form of an
optimization problem:</p>
<p>Consider an <span class="math inline">\(ℝ\)</span>-valued function <span class="math inline">\(f\)</span> defined for <span class="math inline">\(\mathbf{x} \in ℝ^n\)</span> –
thus, <span class="math inline">\(f:ℝ^n \to ℝ\)</span>. We want to optimize <span class="math inline">\(f(\mathbf{x})\)</span> subject to a
system of <em>constraints</em> defined by some auxiliary data.</p>
<p>We first consider <span class="math inline">\(E\)</span> constraints defined for <span class="math inline">\(1 \le i \le E\)</span> by
functions <span class="math inline">\(g_i:ℝ^n \to ℝ\)</span> together with values <span class="math inline">\(b_i \in ℝ\)</span>; these
constraints have the form
<span class="math display">\[(\heartsuit)_i \quad g_i(\mathbf{x}) \le b_i \]</span></p>
<p>At the same time, we consider <span class="math inline">\(F\)</span> constraints defined for
<span class="math inline">\(1 \le j \le F\)</span> by functions <span class="math inline">\(h_j:ℝ^n \to ℝ\)</span> together with values
<span class="math inline">\(c_j \in ℝ\)</span>; these constraints have the form
<span class="math display">\[ (\clubsuit)_j \quad h_j(\mathbf{x}) = c_j \]</span></p>
<p>Re-capping, the problem is to find the optimal value of <span class="math inline">\(f(\mathbf{x})\)</span>
where <span class="math inline">\(\mathbf{x}\)</span> ranges over all points in <span class="math inline">\(ℝ^n\)</span> satisfying the
constraints <span class="math inline">\((\heartsuit)_i\)</span> and all constraints <span class="math inline">\((\clubsuit)_j\)</span>.</p>
<hr />
<p>Compactly, a <em>general optimization problem</em> asks to find the maximum (or
minimum) of <span class="math inline">\(f:ℝ^n \to ℝ\)</span> for <span class="math inline">\(\mathbf{x} \in ℝ^n\)</span> subject to
constraints <span class="math display">\[\begin{aligned} g_i(\mathbf{x}) &amp; \le b_i &amp; 1 \le i \le
E \\ h_j(\mathbf{x}) &amp; = c_j &amp; 1 \le j \le F \end{aligned}\]</span> For
functions <span class="math inline">\(g_i,h_j:ℝ^n \to ℝ\)</span> and scalars <span class="math inline">\(b_i,c_j\)</span>.
:::</p>
<div id="0b58f3f6-1769-45f3-88ce-82809186a697" class="cell markdown">
<h2 id="remarks">Remarks</h2>
<ul>
<li>One might wonder why we don’t consider constraints of the form
<span class="math display">\[\ell(\mathbf{x}) &lt; d \quad \text{or} \quad
 \ell(\mathbf{x}) \ge d \quad \text{or} \quad
 \ell(\mathbf{x}) &gt; d\]</span></li>
</ul>
<p>The answer is that the conditions imposed by constraints of these form
can be achieved by using (possibly more) constraints of the forms
<span class="math inline">\((\heartsuit)_i\)</span> or <span class="math inline">\((\clubsuit)_j\)</span>.</p>
<ul>
<li><p>Our older examples all (essentially) have this form:</p>
<ul>
<li><p>For example, single-variable optimization amounts to the case
<span class="math inline">\(n =1\)</span> - i.e. <span class="math inline">\(f\)</span> is a function <span class="math inline">\(ℝ \to ℝ\)</span>. Typically we optimize
on an interval – for example we might want to optimize <span class="math inline">\(f\)</span> for
<span class="math inline">\(x\)</span> in the closed interval <span class="math inline">\([a,b]\)</span>. Then one of the constraints
has the form <span class="math inline">\(x \le b\)</span> (so this constraint has the form
<span class="math inline">\((\heartsuit)\)</span>, <span class="math inline">\(g_1\)</span> is just the identity function, and
<span class="math inline">\(b_1 = b\)</span>) and the constraint <span class="math inline">\(a \le x\)</span> also has the form
<span class="math inline">\((\heartsuit)\)</span>, <span class="math inline">\(g_2(x) = -x\)</span>, and <span class="math inline">\(b_2 = -a\)</span>).</p></li>
<li><p>The Lagrange multiplier optimization examples that we’ve seen
amount to the case of a single constraint of type <span class="math inline">\((\clubsuit)\)</span>.</p></li>
</ul></li>
</ul>
</div>
<div id="ddeee34d-5eb5-4483-a598-9045f9e246f5" class="cell markdown">
<h2 id="a-linear-example-carpenter-tables-shelves">A “linear” example: Carpenter; tables; shelves</h2>
<p><em>This example is an instance of a problem in “linear programming”, as
we’ll describe below.</em></p>
<blockquote>
<p>A carpenter can choose to make either tables or bookshelves. She makes
a profit of \$25 per constructed table and \$30 per constructed
bookshelf (demand is sufficient that all constructed products will be
sold).</p>
</blockquote>
<blockquote>
<p>It takes 5 hours of labor and 20 board-feet of lumber to make a table
and 4 hours of labor and 30 board-feet of lumber to make a bookshelf.
If she has access to 120 hours of labor and 690 board-feet of lumber
each week, how many tables and how many bookshelves should she make to
maximize profit?</p>
</blockquote>
<p>What are the variables?</p>
<ul>
<li><span class="math inline">\(t\)</span> = # of tables made per week</li>
<li><span class="math inline">\(b\)</span> = # of bookshelves made per week</li>
<li><span class="math inline">\(p\)</span> = profit per week</li>
<li><span class="math inline">\(L\)</span> = hours of labor per week</li>
<li><span class="math inline">\(W\)</span> = board-feet of lumber used per week</li>
</ul>
<p>What do we know?</p>
<ul>
<li><span class="math inline">\(p = 25t + 30b\)</span></li>
<li><span class="math inline">\(L = 5t + 4b\)</span></li>
<li><span class="math inline">\(W = 20t + 30b\)</span></li>
</ul>
<p>So the <strong>goal</strong> is to maximize <span class="math inline">\(p(t, b) = 25t + 30b\)</span>, subject to the
constraints <span class="math display">\[(\heartsuit) \quad \left \{ \begin{matrix}
L(t,b) = 5t + 4b &amp;  \le 120 \\
W(t,b) = 20t + 30b &amp; \le 690  \\
t &amp; \ge 0 \\
b &amp; \ge 0 \\
\end{matrix} \right.\]</span></p>
<p>It would be useful to have a schematic showing the region of the plane
consting of those points <span class="math inline">\((t,b)\)</span> which satisfy the constraint
<span class="math inline">\((\heartsuit)\)</span>. This set of points is known as the <strong>feasible set</strong> or
<strong>feasible region</strong>.</p>
<p>Let’s start by using <code>matplotlib</code> to draw a representation of this
feasible region.</p>
</div>
<div id="99edb153-c684-4209-ba4c-bc6aa0ecd0ef" class="cell code">
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib notebook</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>plt.rcParams.update({<span class="st">'font.size'</span>: <span class="dv">19</span>})</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the feasible region</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">2</span>,<span class="dv">30</span>,<span class="dv">500</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>t,b <span class="op">=</span> np.meshgrid(d,d)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>fig,ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">15</span>,<span class="dv">15</span>))</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>ax.imshow(((t<span class="op">&gt;=</span><span class="dv">0</span>) <span class="op">&amp;</span> (b<span class="op">&gt;=</span><span class="dv">0</span>) <span class="op">&amp;</span> (<span class="dv">5</span><span class="op">*</span>t <span class="op">+</span> <span class="dv">4</span><span class="op">*</span>b <span class="op">&lt;=</span> <span class="dv">120</span>) <span class="op">&amp;</span> (<span class="dv">20</span><span class="op">*</span>t <span class="op">+</span> <span class="dv">30</span><span class="op">*</span>b <span class="op">&lt;=</span> <span class="dv">690</span>)).astype(<span class="bu">int</span>),</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>          extent<span class="op">=</span>(t.<span class="bu">min</span>(),t.<span class="bu">max</span>(),b.<span class="bu">min</span>(),b.<span class="bu">max</span>()),</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>          origin<span class="op">=</span><span class="st">&quot;lower&quot;</span>, </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>          cmap<span class="op">=</span><span class="st">&quot;Reds&quot;</span>, </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>          alpha <span class="op">=</span> <span class="fl">0.2</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the lines defining the constraints</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">2</span>,<span class="dv">30</span>,<span class="dv">500</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>ax.plot(t, (<span class="dv">120</span> <span class="op">-</span> <span class="dv">5</span><span class="op">*</span>t)<span class="op">/</span><span class="dv">4</span>, label<span class="op">=</span><span class="st">&quot;5t+4b = 120&quot;</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>ax.plot(t, (<span class="dv">690</span> <span class="op">-</span> <span class="dv">20</span><span class="op">*</span>t)<span class="op">/</span><span class="dv">30</span>, label <span class="op">=</span> <span class="st">&quot;20t + 30b = 690&quot;</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>ax.axhline(y<span class="op">=</span><span class="dv">0</span>, color <span class="op">=</span> <span class="st">&quot;black&quot;</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>ax.axvline(x<span class="op">=</span><span class="dv">0</span>, color <span class="op">=</span> <span class="st">&quot;black&quot;</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">&quot;Carpenter - Feasible Region&quot;</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">&quot;t = #tables&quot;</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">&quot;b = #bookcases&quot;</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ann_pt(x,y):</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="ss">f&quot;(</span><span class="sc">{</span>x<span class="sc">}</span><span class="ss">,</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">)&quot;</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    ax.annotate(s,xy<span class="op">=</span>(x,y),xytext<span class="op">=</span>(<span class="dv">5</span>,<span class="dv">5</span>),textcoords<span class="op">=</span><span class="st">'offset points'</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>ax.scatter(<span class="dv">0</span>, <span class="dv">23</span>,s<span class="op">=</span><span class="dv">100</span>,color<span class="op">=</span><span class="st">&quot;blue&quot;</span>)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>ax.scatter(<span class="dv">12</span>,<span class="dv">15</span>,s<span class="op">=</span><span class="dv">100</span>,color<span class="op">=</span><span class="st">&quot;blue&quot;</span>)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>ax.scatter(<span class="dv">24</span>, <span class="dv">0</span>,s<span class="op">=</span><span class="dv">100</span>,color<span class="op">=</span><span class="st">&quot;blue&quot;</span>)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>ax.scatter(<span class="dv">0</span>,  <span class="dv">0</span>,s<span class="op">=</span><span class="dv">100</span>,color<span class="op">=</span><span class="st">&quot;blue&quot;</span>)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>ann_pt(<span class="dv">0</span>,<span class="dv">23</span>)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>ann_pt(<span class="dv">12</span>,<span class="dv">15</span>)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>ann_pt(<span class="dv">24</span>,<span class="dv">0</span>)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>ann_pt(<span class="dv">0</span>,<span class="dv">0</span>)</span></code></pre></div>
</div>
<div id="c5fd3a17-fd96-4882-a3b6-b0c31948b871" class="cell markdown">
<p>The shaded region is the <em>feasible region</em> defined by the constraints
<span class="math inline">\((\heartsuit)\)</span> above. This region is bounded by (parts of) the graphs of
the 4 linear equations: <span class="math display">\[b=0, \quad t=0, \quad 5t+4b=120, \quad
20t + 30b = 690.\]</span></p>
<p>We’ve indicated the points of intersection of these lines.</p>
<p>Recall that we are trying to maximize the profit function
<span class="math inline">\(p(t,b)=25 t+30b\)</span> for points in this feasible region. Notice that
<span class="math display">\[\dfrac{\partial p}{\partial t} = 25 \quad \text{and} \quad
\dfrac{\partial p}{\partial b} = 30,\]</span> so the profit function <em>has no
critical points at all</em>. So the maximum will occur on the <strong>boundary</strong>
of the feasible region.</p>
<p>But the boundary itself is made up of line segments. And on each line
segment, the restriction of <span class="math inline">\(p\)</span> is again a linear function. For example,
on the line <span class="math inline">\(5t+4b=120\)</span>, the profit is given as a function of <span class="math inline">\(t\)</span> by
<span class="math display">\[p_1(t) = p(t,b(t)) = p\left(t,\dfrac{120-5t}{4}\right) = 25
t + \dfrac{30}{4}(120-5t).\]</span> Since <span class="math inline">\(\dfrac{dp_1}{dt} = \dfrac{-50}{4}\)</span>,
again <span class="math inline">\(p_1\)</span> has no critical points; its max on the boundary line segment
will occur at one of the endpoints.</p>
<p>In this manner, we see that <em>the maximum value of <span class="math inline">\(p\)</span> must occur at one
of the itersection points</em> of boundary lines defining the feasible
region, i.e. at one of the points <span class="math display">\[(0,0), \quad (0,23), \quad (24,0),
\quad \text{or} \quad (12,15).\]</span> We find: <span class="math display">\[p(0, 0) = 0, \quad p(24,
0) = 600, \quad p(0, 23) = 690, \quad p(12, 15) = 750\]</span> So her profit is
maximized by producing 12 tables and 15 bookshelves.</p>
</div>
<div id="020b4912-dd43-486e-ae74-5a3b531a6ac8" class="cell markdown">
<h2 id="linear-programming">Linear Programming</h2>
<p>The term <em>linear programming</em> refers to optimization problems in which
the function to be optimized, as well as all of the constraint
equations, are <em>linear</em> functions of the variables.</p>
<p>The strategy used to find the optimal value in the carepentry example
was pretty good! It works well if we only have a few constraints and a
few variables. But if we have <strong>many variables and many constraints</strong>,
we find <strong>a lot</strong> of vertices in high dimensions.</p>
<p>For example, let’s assume given a linear function of 50 variables, and
150 linear constraints (including the conditions that all 50 variables
are non-negative). With 50 variables, we expect a point to be specified
by exactly 50 linear equations. So we expect a point of intersection of
our boundary equations to be determined by selecting 50 of the 150
possible equations. The number of possible ways of choosing 50 items
from 150 possible items is the <a href="https://en.wikipedia.org/wiki/Binomial_coefficient">binomial
coefficient</a>
<span class="math inline">\(\dbinom{150}{50}\)</span> (read this symbols as “150 choose 50”).</p>
<p>Recall that <span class="math display">\[\dbinom{n}{m} = \dfrac{n!}{m!\cdot (n-m)!}\]</span></p>
<p>(where <span class="math inline">\(n!\)</span> means “<span class="math inline">\(n\)</span> factorial”, a quantity that e.g. you met in Calc
II when studying Taylor Series…)</p>
</div>
<div id="8ce6f20e-7bc6-4f66-96b3-54c9aaa93a30" class="cell code">
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> binom(n,m):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.factorial(n)<span class="op">/</span>(math.factorial(m)<span class="op">*</span>math.factorial(n<span class="op">-</span>m))<span class="op">*</span><span class="fl">1e0</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>binom(<span class="dv">150</span>,<span class="dv">100</span>)</span></code></pre></div>
</div>
<div id="36881f2b-701d-4994-b5f9-493dd0e4e97a" class="cell markdown">
<p>So the number of intersection points is approximately:
<span class="math display">\[\dbinom{150}{50} = \dfrac{150!}{100!\cdot 50!} \approx 2 \times
10^{40}.\]</span></p>
<p>Notice that in our carpentry example, there are two variables, and the
boundary is defined by 4 equations. Our estimate predicts
<span class="math inline">\(\dbinom{4}{2} = 6\)</span> intersection points, but of course only 4 of these
points are actually on the boundary. You can see the location of the
“extra” two points in the image above – they are on the coordinate
axes. Nevertheless, for large numbers of variables and equations,
<span class="math inline">\(\dbinom{n}{m}\)</span> is a decent estimate for the number of relevant
intersection points.</p>
<p>There are roughly <span class="math inline">\(3 \times 10^7\)</span> seconds in a year, so a computer that
can evaluate the function at a pair <span class="math inline">\((t,b)\)</span> at a rate of once per
nanosecond (<span class="math inline">\(10^{-9}\)</span> seconds) would take</p>
<p><span class="math display">\[\begin{aligned} \approx &amp; \left(2 \times 10^{40} \text{operations}
\right)\cdot \left (10^{-9} \dfrac{\text{seconds}}{\text{operation}}
\right)\cdot \left(\dfrac{1}{3 \times 10^7}
\dfrac{\text{years}}{\text{second}}\right)&amp; \\ = &amp; \left( \dfrac{2}{3}
\times 10^{24} \right) = 6.\overline{66} \times 10^{23} \quad
\text{years} &amp; \end{aligned}\]</span> – i.e. more than <span class="math inline">\(6 × 10^{23}\)</span> years to
complete the task.</p>
<p>Rather than wait so long, we are going to study an algorithm that
permits us to ignore some of the vertices.</p>
</div>
<div id="8e405102-f892-45fc-ad56-b9d0f43bffcb" class="cell markdown">
<h2 id="linear-programming--some-preliminaries">Linear programming – some preliminaries</h2>
<p>Let’s take a moment and describe linear programming problems using
notation from <em>linear algebra</em>. If there are <span class="math inline">\(n\)</span> variables <span class="math inline">\(x_i\)</span>, we
write
<span class="math inline">\(\mathbf{x} = \begin{bmatrix} x_1 \\ x_2 \\ \vdots \\ x_n \end{bmatrix} \in ℝ^n\)</span>
for the corresponding “variable vector”.</p>
<p>More generally, we denote by <span class="math inline">\(ℝ^{m \times n}\)</span> the space of <span class="math inline">\(m \times n\)</span>
matrices – i.e. matrices with <span class="math inline">\(m\)</span> rows and <span class="math inline">\(n\)</span> columns; thus</p>
<p><span class="math display">\[ℝ^{m \times n} = \left \{ 
\begin{pmatrix} 
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn} \\
\end{pmatrix} \ \bigg \vert\ a_{ij} \in ℝ \right \} \]</span></p>
<p>Now, a linear function <span class="math inline">\(ℝ^n \to ℝ\)</span> is given by a <span class="math inline">\(1 \times n\)</span> matrix –
i.e. a row vector <span class="math display">\[\mathbf{c} = \begin{bmatrix}
c_1 &amp; c_2 &amp; \cdots &amp; c_n\end{bmatrix} \in ℝ^{1 \times n}.\]</span></p>
<p>We will usually reserve the symbol <span class="math inline">\(ℝ^n\)</span> to indicate the space
<span class="math inline">\(ℝ^{n \times 1}\)</span> of <strong>column vectors</strong>; of course, we can view the row
vector <span class="math inline">\(\mathbf{c}\)</span> as the <strong>transpose</strong> of a column vector, if
convenient.</p>
<p>The value of the linear function <span class="math inline">\(ℝ^n \to ℝ\)</span> determined by <span class="math inline">\(\mathbf{c}\)</span>
is given for <span class="math inline">\(\mathbf{x} \in ℝ^n\)</span> by the rule
<span class="math display">\[\mathbf{x} \mapsto \mathbf{c} \cdot \mathbf{x} =
\sum_{i=1}^n c_i x_i\]</span> where <span class="math inline">\(\mathbf{c} \cdot \mathbf{x}\)</span> denotes the
<em>matrix product</em> (which looks suspiciously like the <em>dot product</em>, of
course).</p>
<p>Now, for a general optimization problem, there are inequality
constraints, and equality constraints. In the setting of linear
programming, we further stipulate: - all constraints are given by linear
functions, which are determined (as above) by column vectors in <span class="math inline">\(ℝ^n\)</span>. -
we only consider <em>inequality constraints</em>.</p>
<p>We’ll explain below why <em>equality constraints</em> aren’t needed in linear
programming.</p>
</div>
<div id="330830e2-e628-4059-8557-3dec82be781f" class="cell markdown">
<h2 id="notations">Notations</h2>
<p>We now pause to fix some <em>notation:</em></p>
<p>Suppose that the inequality constraints are determined by linear
functions corresponding to vectors <span class="math display">\[\mathbf{a}_1 = \begin{bmatrix}
a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1,n} \end{bmatrix},
\mathbf{a}_2,\cdots,\mathbf{a}_r \in ℝ^{1 \times n}\]</span> and scalars <span class="math inline">\(b_i\)</span>
for <span class="math inline">\(1 \le i \le r\)</span>.</p>
<p>The <span class="math inline">\(i\)</span>-th inequality constraint requires that <span class="math display">\[\mathbf{a}_i \cdot
\mathbf{x} \le b_i\]</span>.</p>
<p>Now form the <span class="math inline">\(r \times n\)</span> matrix <span class="math inline">\(A\)</span> whose rows are given by the vectors
<span class="math inline">\(\mathbf{a}_i\)</span>: <span class="math display">\[A = \begin{pmatrix} \mathbf{a}_1 \\
\mathbf{a}_2 \\ \vdots \\ \mathbf{a}_r\end{pmatrix}\]</span> The product
<span class="math inline">\(A \cdot \mathbf{x} \in ℝ^r\)</span> is given by <span class="math display">\[A \cdot \mathbf{x} =
\begin{pmatrix} \mathbf{a}_1 \\ \mathbf{a}_2 \\ \vdots \\ \mathbf{a}_r
\end{pmatrix}\cdot \mathbf{x} = \begin{pmatrix} \mathbf{a}_1 \cdot
\mathbf{x} \\ \mathbf{a}_2 \cdot \mathbf{x} \\ \vdots \\ \mathbf{a}_r
\cdot \mathbf{x} \end{pmatrix} \]</span></p>
<p>For any <span class="math inline">\(m \ge 1\)</span>, we declare that two vectors <span class="math inline">\(\mathbf{y}\)</span> and
<span class="math inline">\(\mathbf{z}\)</span> of <span class="math inline">\(ℝ^m\)</span> satisfy <span class="math inline">\(\mathbf{y} \le \mathbf{z}\)</span> if and only if
<span class="math inline">\(y_i \le z_i\)</span> for each <span class="math inline">\(1 \le i \le m\)</span>. With this convention, the
inequality constraints determined by the <span class="math inline">\(\mathbf{a}_i\)</span> and <span class="math inline">\(b_i\)</span> can be
written: <span class="math display">\[A \cdot \mathbf{x} \le
\mathbf{b} = \begin{bmatrix} b_1 \\ b_2 \\ \vdots \\
b_r\end{bmatrix}.\]</span></p>
</div>
<div id="0017308d-5464-4214-9d91-8212035b10c7" class="cell markdown">
<h2 id="standard-form">Standard Form</h2>
<p>Recapitulating, a <strong>linear programming problem</strong> is determined by the
number <span class="math inline">\(n\)</span> of variables, the choice of vectors
<span class="math inline">\(\mathbf{c}, \mathbf{a}_1, \mathbf{a}_2,\cdots,\mathbf{a}_r \in ℝ^{1 \times n}\)</span>
and the choice of scalars <span class="math inline">\(b_1,\dots,b_r\)</span>.</p>
<p>The goal is to maximize <span class="math inline">\(\mathbf{c} \cdot \mathbf{x}\)</span> subject to the
constraint <span class="math display">\[\mathbf{A} \cdot \mathbf{x} \le \mathbf{b}\]</span> where
<span class="math inline">\(A = \begin{pmatrix} \mathbf{a}_1 \\ \mathbf{a}_2 \\ \vdots \\ \mathbf{a}_r \end{pmatrix}\)</span>
is the <span class="math inline">\(r \times n\)</span> matrix whose rows are the row-vectors <span class="math inline">\(\mathbf{a}_i\)</span>
and <span class="math inline">\(\mathbf{b} \in ℝ^r\)</span> has entries <span class="math inline">\(b_i\)</span>.</p>
<p>We say that the linear programming problem is posed in standard form if
it has this form.</p>
<ul>
<li><strong>Remark</strong>: if <span class="math inline">\(\mathbf{a} \in ℝ^{1 \times n}\)</span> and <span class="math inline">\(b \in ℝ\)</span>, an
inequality constraint of the form <span class="math display">\[(\clubsuit) \quad
\mathbf{a} \cdot \mathbf{x} \ge b\]</span> can be rewritten in “standard
form” by taking <span class="math inline">\(\mathbf{\widetilde a} = -\mathbf{a}\)</span> and
<span class="math inline">\(\widetilde b = -b\)</span>; then <span class="math inline">\((\clubsuit)\)</span> is equivalent to
<span class="math display">\[\mathbf{\widetilde a}
\cdot \mathbf{x} \le \widetilde b\]</span>.</li>
</ul>
</div>
<div id="776ad836-f38c-4105-a18c-f0d176fd899b" class="cell markdown">
<h2 id="why-do-we-impose-no-equality-constraints">Why do we impose no equality constraints??</h2>
<p>Consider a <em>linear programming problem</em> as above, but suppose also that
we imposed <em>equality constraints</em> determined by vectors
<span class="math display">\[\mathbf{b}_1 ,\mathbf{b}_2,\cdots,\mathbf{b}_s\]</span> in <span class="math inline">\(ℝ^{1 \times n}\)</span>
and the scalar values <span class="math display">\[\gamma_1,\gamma_2,\cdots,\gamma_s\]</span></p>
<p>In other words, the <span class="math inline">\(i\)</span>th equality constraint requires that</p>
<p><span class="math display">\[(\clubsuit) \quad \mathbf{b}_i \cdot \mathbf{x} = \gamma_i\]</span></p>
<p>Now form the <span class="math inline">\(s \times n\)</span> matrix <span class="math inline">\(B\)</span> whose rows are the <span class="math inline">\(\mathbf{b}_i\)</span>:</p>
<p><span class="math display">\[B = \begin{pmatrix} \mathbf{b}_1 \\ \mathbf{b}_2 \\ \vdots \\
\mathbf{b}_s \end{pmatrix}\]</span></p>
<p>The product <span class="math inline">\(B \cdot \mathbf{x} \in ℝ^s\)</span> is given by</p>
<p><span class="math display">\[B \cdot \mathbf{x} = \begin{pmatrix} \mathbf{b}_1 \\ \mathbf{b}_2 \\
\vdots \\ \mathbf{b}_s \end{pmatrix}\cdot \mathbf{x} = \begin{pmatrix}
\mathbf{b}_1 \cdot \mathbf{x} \\ \mathbf{b}_2 \cdot \mathbf{x} \\
\vdots \\ \mathbf{b}_s \cdot \mathbf{x} \end{pmatrix}\]</span></p>
<p>Now, the equality constraints amount to the condition that</p>
<p><span class="math display">\[(\heartsuit) \quad B \cdot \mathbf{x} = \begin{pmatrix} \gamma_1 \\
\gamma_2 \\ \vdots \\ \gamma_s \end{pmatrix}\]</span>.</p>
<p>An important observation of <em>linear algebra</em> is that the solution set to
<span class="math inline">\((\heartsuit)\)</span> has the form <span class="math display">\[\mathbf{x}_0 +
\operatorname{Null}(B)\]</span> where <span class="math inline">\(\mathbf{x}_0\)</span> is any <em>particular
solution</em> to <span class="math inline">\((\heartsuit)\)</span> and where <span class="math inline">\(\operatorname{Null}(B)\)</span> is the
<em>null space</em> of <span class="math inline">\(B\)</span> – <span class="math display">\[\operatorname{Null}(B) = \left \{\mathbf{z}
\in ℝ^n \mid B \cdot \mathbf{z} = \mathbf{0}\right\}.\]</span></p>
<p>Now, <span class="math inline">\(W=\operatorname{Null}(B)\)</span> is a <em>linear subspace</em> of <span class="math inline">\(ℝ^n\)</span>. Let
<span class="math inline">\(k = \dim W \le n\)</span> be the <em>dimension</em> of this null space. If we choose a
basis for <span class="math inline">\(W\)</span>, we can identify this space with <span class="math inline">\(ℝ^k\)</span>. In case
<span class="math inline">\((\heartsuit)\)</span> has a solution <span class="math inline">\(\mathbf{x}_0\)</span> at all, the set
<span class="math inline">\(\mathbf{x}_0 + \operatorname{Null}(B) = \mathbf{x}_0 + W\)</span> can similarly
be identified with <span class="math inline">\(ℝ^k\)</span> (just translate the origin!).</p>
<ul>
<li><p>The upshot of all this is that <em>when we talk about how to solve a
linear programming problem, we are free to only consider such
problems which have no equality constraints</em>. Indeed, imposing
equality constraints really amounts to reducing the number of
variables of the problem (from <span class="math inline">\(n\)</span> to <span class="math inline">\(k\)</span>).</p></li>
<li><p>It is of course quite reasonable to impose equality constraints.</p>
<p>Such a linear programming problem is not in standard form, but it
can be translated into standard form essentially by choosing a basis
for the null space <span class="math inline">\(W\)</span> and working in the resulting new “coordinate
system”.</p>
<p>Of course, there is then also additional work in adapting the
inequality constraints to this new coordinate system!!</p></li>
</ul>
</div>
<div id="cc0fe3c9-6bde-4ed1-9ccd-9edd1d54914e" class="cell markdown">
<h2 id="example-eliminating-equality-constraints">Example: eliminating equality constraints</h2>
<p>A simple example should illustrate the idea just described</p>
<p>Consider the linear program in 2 variables <span class="math inline">\(x,y\)</span> which seeks to minimize
the value of the function given by
<span class="math inline">\(\mathbf{c} = \begin{bmatrix} c_1 &amp; c_2 \end{bmatrix}\)</span> subject to the
constraints:</p>
<ul>
<li><p><span class="math inline">\(\mathbf{0} \le \mathbf{x} = \begin{bmatrix} x \\ y \end{bmatrix}\)</span></p></li>
<li><p><span class="math inline">\(\begin{bmatrix} 1 &amp; 1 \end{bmatrix} \cdot \mathbf{x} \le 3\)</span></p></li>
</ul>
<p>and</p>
<ul>
<li><span class="math inline">\(\begin{bmatrix} -\lambda &amp; 1 \end{bmatrix} \cdot \mathbf{x} = 1\)</span></li>
</ul>
<p>for some scalar quantity <span class="math inline">\(\lambda &gt; 0\)</span>.</p>
<p>Of course, the equality constraint
<span class="math inline">\(\begin{bmatrix} -\lambda &amp; 1\end{bmatrix} \cdot \mathbf{x} = 1\)</span> just
says that <span class="math inline">\(y = \lambda x + 1\)</span> - i.e. the point <span class="math inline">\((x,y)\)</span> must lie on the
line with slope <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(y\)</span> intercept <span class="math inline">\(1\)</span>.</p>
<p>Thus we can rewrite the “non-negative” constraint: since $&gt; 0 $, it
says that <span class="math display">\[\mathbf{0} \le \mathbf{x} = \begin{bmatrix} x \\
\lambda x + 1\end{bmatrix} \implies 0 \le x \quad \text{and} \quad 0
\le \lambda x + 1 \implies 0 \le x \quad \text{and} \quad
\dfrac{-1}{\lambda} \le x \implies 0 \le x.\]</span> And we can rewrite the
remaining inequality constraint: it now says that <span class="math display">\[\begin{bmatrix} 1
&amp; 1 \end{bmatrix} \cdot \begin{bmatrix} x \\ \lambda x +
1\end{bmatrix} \le 3\]</span> i.e. <span class="math display">\[(1+\lambda)x + 1 \le 3 \implies
(1+\lambda)x \le 2 \implies x \le \dfrac{2}{1+\lambda}.\]</span></p>
<p>Finally, we can rewrite the objective function: it is <span class="math display">\[\mathbf{c}
\cdot \mathbf{x} = \begin{bmatrix} c_1 &amp; c_2 \end{bmatrix} \cdot
\begin{bmatrix} x \\ \lambda x + 1\end{bmatrix} = c_1 x + c_2(\lambda
x + 1) = (c_1 + \lambda c_2)x + c_2\]</span></p>
<p>Thus the “new” (but equivalent!) problem is to minimize the linear
function of <span class="math inline">\(x\)</span> given by <span class="math inline">\(\ell(x) = (c_1 + \lambda c_2)x + c_2\)</span> for <span class="math inline">\(x\)</span>
in the interval <span class="math display">\[\left[0,\dfrac{2}{1+\lambda}\right].\]</span></p>
<p>(Of course, <span class="math inline">\(\ell\)</span> will be minimized on one of the endpoints of the
interval; which endpoint depends only on the sign of the expression
<span class="math inline">\(c_1 + \lambda c_2\)</span>).</p>
</div>
<div id="ebbfc322-9c03-4a87-9851-5b6d3880c40b" class="cell markdown">
<h2 id="remarks-about-linear-programming">Remarks about <a href="https://en.wikipedia.org/wiki/Linear_programming">linear programming</a></h2>
<h3 id="history">History</h3>
<p>The idea arose during World War II to reduce costs for the military. It
was first developed in 1939 by <a href="https://en.wikipedia.org/wiki/Leonid_Kantorovich">Leonid
Kantorovich</a>, a
Russian mathematician and economist. In the 1970s, he won the Nobel
Prize in Economics for his “contributions to the theory of optimum
allocation of resources.”</p>
<p>For more information, see this <a href="https://en.wikipedia.org/wiki/Linear_programming#History">historical
discussion</a>.
Significant contributions include the <a href="https://en.wikipedia.org/wiki/Simplex_algorithm">simplex
method</a>, invented by
George Dantzig in the late 1940s.</p>
<h3 id="applications">Applications</h3>
<p>Linear programming problems arise naturally in many settings: - minimal
staffing needed to complete scheduled tasks - maximizing profit &amp;
minimizing costs when considering multiple options - minimizing risk of
investment subject to achieving a return - minimizing transport costs</p>
</div>
<div id="cdc48537-1c17-467a-bdf9-be5f2b51081f" class="cell markdown">
<h2 id="using-scipy-to-solve-linear-programs">Using <code>scipy</code> to solve linear programs</h2>
<p>Before we discuss how</p>
<p>The <code>scipy</code> library (more precisely, the <code>scipy.optimize</code> library)
provides a <code>python</code> function which implements various algorithms for
solving linear programs.</p>
<p>The <code>API</code> interface of this function can be found here:</p>
<p><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html">docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html</a></p>
<p>Here is a minimalist sketch.</p>
<blockquote>
<p>The function call</p>
<pre><code>linprog(c,A_ub=A,b_ub=v)</code></pre>
</blockquote>
<blockquote>
<p>for a 1 dimensional “row vector” c of dimension <span class="math inline">\(n\)</span> <em>minimizes</em> the
linear objective function <span class="math display">\[\mathbf{x} \mapsto \mathbf{c}\cdot
\mathbf{x}\]</span> subject to constraint <span class="math display">\[A \cdot \mathbf{x} \le
\mathbf{v}\]</span> determined by the <span class="math inline">\(r \times n\)</span> matrix <span class="math inline">\(A\)</span> and the vector
<span class="math inline">\(\mathbf{v} \in \mathbb{R}^r\)</span>.</p>
</blockquote>
<blockquote>
<p>The function call</p>
<pre><code>linprog(c,A_ub=A,b_ub=v,A_eq=B,b_eq=w)</code></pre>
</blockquote>
<blockquote>
<p><em>minimizes</em> the objective function determined by <span class="math inline">\(\mathbf{c}\)</span> subject
to the inequality constraint as before, but also the equality
constraint <span class="math inline">\(B\mathbf{x} = \mathbf{w}\)</span> determined by the <span class="math inline">\(s \times n\)</span>
matrix <span class="math inline">\(B\)</span> and the vector <span class="math inline">\(\mathbf{w} \in \mathbb{R}^s\)</span>.</p>
</blockquote>
<blockquote>
<p><code>linprog</code> can also take an additional keywork argument <code>bounds</code>; if
<code>bounds</code> is not provided, the default requirement is
<span class="math inline">\(\mathbf{0} \le \mathbf{x}\)</span>.</p>
</blockquote>
</div>
<div id="44c086c7-0ca0-4d46-b283-d07bb0b0fbc7" class="cell markdown">
<h3 id="remarks">Remarks:</h3>
<ul>
<li><p>Note that use of the equality constraint and the argument <code>bounds</code>
asks <code>linprog</code> to solve linear programs that aren’t in standard
form. The “default” value of <code>bounds</code> could have been achieved by
adding extra rows to <span class="math inline">\(A\)</span>; indeed, consider the <span class="math inline">\((r+n) \times 2n\)</span>
matrix <span class="math display">\[\widetilde{A} = \begin{pmatrix} A &amp; \mathbf{0} \\
\mathbf{0} &amp; -I_n \end{pmatrix}\]</span> and the vector
<span class="math display">\[\widetilde{\mathbf{b}} = \begin{bmatrix} \mathbf{b} \\ \mathbf{0}
\end{bmatrix} \in ℝ^{r+n};\]</span> the inequality constraint
<span class="math display">\[\widetilde{A} \cdot \mathbf{x} \le \widetilde{\mathbf{b}}\]</span> is
equivalent to the pair of contraints <span class="math display">\[A \cdot \mathbf{x} \le
\mathbf{b}, \quad \mathbf{0} \le \mathbf{x}\]</span>.</p></li>
<li><p>the <code>linprog</code> function has other optional keyword arguments,
including <code>method</code> which may be one of the strings ‘interior-point’,
‘revised-simplex’, ‘simplex’; For example, the call
<code>linprog(c,A_ub=A,b_ub=b,method='revised-simplex')</code> will use the
<em>revised-simplex</em> algorithm to solve the linear program. By default,
<code>linprog</code> uses the <em>interior-point</em> algorithm.</p></li>
<li><p>We are going to apply the <code>linprog</code> function to check the solution
of our <em>carpenter</em> example. Notice that the <code>scipy</code> implementation
of <code>linprog</code> always <em>minimizes</em> its objective function. Of course,
maximizing the linear objective function determined by the row
vector <span class="math inline">\(\mathbf{c} \in ℝ^{1 \times r}\)</span> is the same as minimizing the
linear objective function determined by <span class="math inline">\(-\mathbf{c}\)</span>.</p></li>
</ul>
</div>
<div id="0eecdabe-c12e-4322-84cd-1a4d4957d5e0" class="cell markdown">
<h2 id="some-examples">Some examples</h2>
<p>Here is the solution to the <em>carpenter example</em> obtained via <code>scipy</code>:</p>
</div>
<div id="7fa4db64-a97e-449c-b801-97ab575c7d6e" class="cell code">
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> linprog</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Here is the &quot;carpenter example&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> np.array([<span class="dv">25</span>,<span class="dv">30</span>])</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="dv">5</span>,<span class="dv">4</span>],[<span class="dv">20</span>,<span class="dv">30</span>]])</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([<span class="dv">120</span>,<span class="dv">690</span>])</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>res<span class="op">=</span>linprog((<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>c,A_ub<span class="op">=</span>A,b_ub<span class="op">=</span>b)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(res)</span></code></pre></div>
</div>
<div id="da59be14-7710-4bd1-b140-21ae0d8b14b6" class="cell markdown">
<h2 id="higher-dimensional-example">Higher dimensional example</h2>
<p>Here is an example with more variables:</p>
<p>Maximize the value of the linear function given by
<span class="math display">\[\mathbf{c} = \begin{bmatrix} 5 &amp; 4 &amp; 3 \end{bmatrix}\]</span> and with
inequality constraints determined by
<span class="math display">\[\begin{bmatrix} 2 &amp; 3 &amp; 1\end{bmatrix}\cdot \mathbf{x} \le 5\]</span>
<span class="math display">\[\begin{bmatrix} 4 &amp; 1 &amp; 2\end{bmatrix}\cdot \mathbf{x} \le 11\]</span>
<span class="math display">\[\begin{bmatrix} 3 &amp; 4 &amp; 2\end{bmatrix}\cdot \mathbf{x} \le 8\]</span>
<span class="math display">\[\mathbf{0} \le \mathbf{x}\]</span> where <span class="math display">\[\mathbf{x} = \begin{bmatrix}
x \\
y \\
z
\end{bmatrix}\]</span></p>
<p>Note that the constraint <span class="math display">\[\mathbf{0} \le \mathbf{x}\]</span> is imposed <em>by
default</em> by the <code>linprog</code> function of <code>scipy</code>.</p>
</div>
<div id="8fd57ffc-b48b-44b1-b22c-1da3c1560d73" class="cell code">
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> np.array([<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>])</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>],</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">2</span>],</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">2</span>]])</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">8</span>])</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>res<span class="op">=</span>linprog((<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>c,A_ub<span class="op">=</span>A,b_ub<span class="op">=</span>b)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># by default, linprog imposes bounds requiring non-negative coordinates</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(res)</span></code></pre></div>
</div>
<div id="7d6952f1-368e-4fac-8992-50629dacca35" class="cell markdown">
<p>So the solution is <span class="math display">\[\mathbf{x} = \begin{bmatrix}
x \\
y \\
z
\end{bmatrix} \approx \begin{bmatrix}
2 \\
0 \\
1 
\end{bmatrix}\]</span></p>
</div>
        </main>

        <footer>
	  <nav>
	    <a href="http://www.tufts.edu">
	      <i class="fas fa-chalkboard"></i>
	      Tufts
	    </a>	    
	    <a href="http://math.tufts.edu">
	      <i class="fas fa-chalkboard-teacher"></i>
	      Tufts Math
	    </a>
	    <a href="https://gmcninch-tufts.github.io/math">
	      <i class="fas fa-coffee"></i>
	      G McNinch
	    </a>
	    <a href="https://github.com/gmcninch-tufts">
	      <i class="fab fa-github"></i>
	      GitHub
	    </a>	    
	  </nav>
        </footer>
    </body>
</html>
